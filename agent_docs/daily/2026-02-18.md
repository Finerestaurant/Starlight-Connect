# 2026년 2월 18일: Frontend-Backend 동작 흐름도 작성

**핵심 목표:** agent_docs, frontend, backend 폴더를 분석하여 프론트엔드가 백엔드를 어떻게 호출하는지 전체 흐름을 시각화하고 문서화합니다.

## 작업 내용

### 1. 코드베이스 분석 (완료)

#### Frontend 분석
- **App.jsx**: 메인 애플리케이션 컴포넌트
  - 초기 focus 상태 관리 (기본값: Nas 아티스트)
  - 노드 클릭 핸들러 (handleNodeClick)
  - 히스토리 관리
  - ReactFlow를 통한 그래프 렌더링

- **SearchBar.jsx**: 검색 기능
  - `/search?q={query}` API 호출
  - 300ms debounce 적용으로 성능 최적화
  - 검색 결과를 드롭다운으로 표시

- **useGraphData.jsx**: 그래프 데이터 패칭 Hook
  - focus 변경 감지 (useEffect)
  - 타입에 따른 API 선택:
    - person → `/artists/mbid/{mbid}/collaboration-details`
    - song → `/songs/mbid/{mbid}/graph-details`
  - 로딩 상태 및 에러 처리

- **layout.js**: 노드 배치 및 스타일링
  - getLayoutedElements 함수로 노드/엣지 배치 계산
  - 0도(중심), 1도(곡), 2도(협업자) 노드 구분
  - 원형 배치 알고리즘

#### Backend 분석
- **main.py**: FastAPI 엔드포인트
  - `/search`: 아티스트/곡 검색 (Line 228)
  - `/artists/mbid/{mbid}/collaboration-details`: 아티스트 협업 데이터 (Line 216)
  - `/songs/mbid/{mbid}/graph-details`: 곡 참여자 데이터 (Line 115)
  - CORS 설정으로 localhost:5173 허용

- **crud.py**: 데이터베이스 쿼리 로직
  - `get_collaboration_details_by_mbid`: 아티스트의 협업 정보
  - `get_song_graph_details_by_mbid`: 곡의 참여자 정보
  - `search_persons_by_name`, `search_songs_by_title`: 검색 기능

### 2. 흐름도 작성 (완료)

**파일**: `agent_docs/frontend-backend-flow.md`

다음 내용을 포함한 포괄적인 문서 작성:

1. **전체 아키텍처 흐름도**: Mermaid 다이어그램으로 사용자-프론트엔드-백엔드 간 상호작용 시각화

2. **3가지 주요 흐름 상세 설명**:
   - 애플리케이션 초기화 흐름 (Sequence Diagram)
   - 검색 기능 흐름 (Sequence Diagram)
   - 노드 클릭 흐름 (Sequence Diagram)

3. **Backend API 엔드포인트 목록**: 테이블 형식으로 정리
   - 엔드포인트, 메서드, 설명, 호출 위치

4. **Frontend 컴포넌트 구조**: 컴포넌트 간 관계도

5. **Backend 서비스 구조**: 모듈 간 의존성 다이어그램

6. **데이터 흐름 요약**: 각 시나리오별 단계별 설명

7. **기술 스택 및 최적화 포인트**: 사용된 주요 기술과 성능 최적화 방법

### 3. 문서 특징

- **시각화**: 5개의 Mermaid 다이어그램으로 직관적 이해 가능
- **상세성**: 각 흐름의 코드 라인 번호까지 참조
- **실용성**: 개발자가 즉시 코드를 찾아갈 수 있도록 파일 경로와 라인 명시
- **완전성**: Frontend → Backend → Database까지 전체 데이터 흐름 커버

## 주요 발견 사항

1. **API 호출 최소화**: 
   - Frontend에서 3개의 API만 직접 호출 (검색, 아티스트 그래프, 곡 그래프)
   - 나머지 데이터 수집 API는 관리자용

2. **효율적인 상태 관리**:
   - focus 객체 하나로 전체 그래프 상태 제어
   - useEffect를 통한 자동 데이터 갱신

3. **성능 최적화**:
   - 검색 debounce (300ms)
   - 조건부 렌더링
   - 최소 데이터 전송 (검색 결과)

4. **명확한 관심사 분리**:
   - 데이터 패칭: useGraphData Hook
   - 레이아웃 계산: layout.js
   - UI 렌더링: 각 컴포넌트

## 다음 단계 제안

1. **성능 개선**:
   - API 응답 캐싱 고려
   - 그래프 데이터 페이지네이션 (많은 협업자)

2. **사용자 경험**:
   - 로딩 스피너 개선
   - 에러 메시지 구체화

3. **문서화**:
   - API 응답 스키마 예시 추가
   - 에러 코드 및 처리 방법 문서화

---

**작업 소요 시간**: 약 1시간
**작성된 다이어그램 수**: 5개
**분석된 파일 수**: Frontend 4개, Backend 2개 (주요 파일 기준)
